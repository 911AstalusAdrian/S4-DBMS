	The deadlock occurs because whenever we want to modify a row of our table (Groups in this case), the transaction that makes this modification requires an exclusive lock (regardless of the isolation level). This exclusive lock is released only when a transaction ends (commit or rollback).
	In our case, T1 first acquires an exclusive lock on the row with the 'groupId' = 4, and T2 acquires an exclusive lock on the row with the 'groupId' = 5. But next, T1 tries to acquire a lock on the row that is already in use by T2 ('groupId' = 5), and it stops here, waiting for the lock in T2 to be released. In the same manner, T2 will stop and wait for the lock in T1 to be released ('groupId' = 4). This means that each transaction waits for the other one to end and release its lock, reaching a deadlock.
	One way of solving this concurrency issue would be changing the order in which the rows are accessed in either one of the Transactions (change them in such a way that the rows are modified in the same order, for example update row 4 first in both Transactions).
	Another solution would be to set the deadlock priority to 'HIGH' for one of the transactions. In this way, the order in which the rows are accessed won't have to change, but, when reaching the deadlock, the Transaction with a lower deadlock priority will be aborted.